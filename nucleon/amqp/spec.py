# Autogenerated - do not edit
import datetime
import struct
import table


# Tables of method ids to decode functions
METHODS = {}


class Buffer(object):
    """A string that can be decoded sequentially."""
    __slots__ = 's', 'offset'

    def __init__(self, s):
        self.s = str
        self.offset = 0

    def read(self, fmt):
        out = struct.unpack_from(fmt, self.s, self.offset)
        self.offset += struct.calcsize(fmt)
        return out

    def read_string(self, fmt='!I'):
        size = self.read(fmt)
        return self.read_bytes(size)

    def read_bytes(self, bytes):
        out = self.s[self.offset:self.offset + bytes]
        self.offset += bytes
        return out

    def read_table(self):
        result, offset = table.decode(self.s, self.offset)
        self.offset = offset
        return result


class FrameMeta(type):
    def __new__(cls, main, bases, dict):
        t = type.__new__(cls, main, bases, dict)
        if 'method_id' in dict:
            METHODS[dict['method_id']] = t
        return t


class Frame(object):
    __metaclass__ = FrameMeta

    has_content = False
    is_error = False

    def __init__(self, *args):
        for k, v in zip(self.__slots__, args):
            setattr(self, k, v)


def encode_message(frame, headers, body, frame_size):
    """Encode message headers and body as a sequence of frames."""
    yield frame.encode()
    props, headers = split_headers(headers, BASIC_PROPS_SET)
    if headers:
        props['headers'] = headers
    yield encode_basic_properties(len(body), props)
    for chunk in encode_body(body, frame_size):
        yield chunk


def split_headers(user_headers, properties_set):
    """Split bitfield properties from named headers."""
    props = {}
    headers = {}
    for key, value in user_headers.iteritems():
        if key in properties_set:
            props[key] = value
        else:
            headers[key] = value
    return props, headers


def encode_body(body, frame_size):
    """Generate a sequence of chunks for body where each chunk is less than frame_size"""
    limit = frame_size - 7 - 1   # spec is broken...
    while body:
        payload, body = body[:limit], body[limit:]
        yield (0x03, payload)

PREAMBLE = 'AMQP\x00\x00\x09\x01'

CLASS_BASIC             = 0x003C




class FrameConnectionStart(Frame):
    __slots__ = ('version_major', 'version_minor', 'server_properties', 'mechanisms', 'locales')
    name = 'connection.start'
    method_id = 0x000A000A  # 10,10 655370

    def __init__(self, version_major=0, version_minor=9, server_properties=None, mechanisms='PLAIN', locales='en_US'):
        super(FrameConnectionStart, self).__init__(version_major, version_minor, server_properties, mechanisms, locales)

    @staticmethod
    def decode(buffer):
        version_major, version_minor = buffer.read('!BB')
        server_properties = buffer.read_table()
        mechanisms = buffer.read_string('!I')
        locales = buffer.read_string('!I')
        return FrameConnectionStart(version_major, version_minor, server_properties, mechanisms, locales)

    def encode(self):
        server_properties_raw = table.encode(self.server_properties)
        yield (0x01,
            ''.join([
                struct.pack('!IBB', self.method_id, self.version_major, self.version_minor),
                self.server_properties_raw,
                struct.pack('!I', len(self.mechanisms)),
                self.mechanisms,
                struct.pack('!I', len(self.locales)),
                self.locales,
            ])
        )


class FrameConnectionStartOk(Frame):
    __slots__ = ('client_properties', 'mechanism', 'response', 'locale')
    name = 'connection.start_ok'
    method_id = 0x000A000B  # 10,11 655371

    def __init__(self, client_properties=None, mechanism='PLAIN', response=None, locale='en_US'):
        super(FrameConnectionStartOk, self).__init__(client_properties, mechanism, response, locale)

    @staticmethod
    def decode(buffer):
        client_properties = buffer.read_table()
        mechanism = buffer.read_string('!B')
        response = buffer.read_string('!I')
        locale = buffer.read_string('!B')
        return FrameConnectionStartOk(client_properties, mechanism, response, locale)

    def encode(self):
        client_properties_raw = table.encode(self.client_properties)
        yield (0x01,
            ''.join([
                struct.pack('!I', self.method_id),
                self.client_properties_raw,
                struct.pack('!B', len(self.mechanism)),
                self.mechanism,
                struct.pack('!I', len(self.response)),
                self.response,
                struct.pack('!B', len(self.locale)),
                self.locale,
            ])
        )


class FrameConnectionSecure(Frame):
    __slots__ = ('challenge',)
    name = 'connection.secure'
    method_id = 0x000A0014  # 10,20 655380

    def __init__(self, challenge=None):
        super(FrameConnectionSecure, self).__init__(challenge)

    @staticmethod
    def decode(buffer):
        challenge = buffer.read_string('!I')
        return FrameConnectionSecure(challenge)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!II', self.method_id, len(self.challenge)),
                self.challenge,
            ])
        )


class FrameConnectionSecureOk(Frame):
    __slots__ = ('response',)
    name = 'connection.secure_ok'
    method_id = 0x000A0015  # 10,21 655381

    def __init__(self, response=None):
        super(FrameConnectionSecureOk, self).__init__(response)

    @staticmethod
    def decode(buffer):
        response = buffer.read_string('!I')
        return FrameConnectionSecureOk(response)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!II', self.method_id, len(self.response)),
                self.response,
            ])
        )


class FrameConnectionTune(Frame):
    __slots__ = ('channel_max', 'frame_max', 'heartbeat')
    name = 'connection.tune'
    method_id = 0x000A001E  # 10,30 655390

    def __init__(self, channel_max=0, frame_max=0, heartbeat=0):
        super(FrameConnectionTune, self).__init__(channel_max, frame_max, heartbeat)

    @staticmethod
    def decode(buffer):
        channel_max, frame_max, heartbeat = buffer.read('!HIH')
        return FrameConnectionTune(channel_max, frame_max, heartbeat)

    def encode(self):
        yield (0x01,
            struct.pack('!IHIH', self.method_id, self.channel_max, self.frame_max, self.heartbeat),
        )


class FrameConnectionTuneOk(Frame):
    __slots__ = ('channel_max', 'frame_max', 'heartbeat')
    name = 'connection.tune_ok'
    method_id = 0x000A001F  # 10,31 655391

    def __init__(self, channel_max=0, frame_max=0, heartbeat=0):
        super(FrameConnectionTuneOk, self).__init__(channel_max, frame_max, heartbeat)

    @staticmethod
    def decode(buffer):
        channel_max, frame_max, heartbeat = buffer.read('!HIH')
        return FrameConnectionTuneOk(channel_max, frame_max, heartbeat)

    def encode(self):
        yield (0x01,
            struct.pack('!IHIH', self.method_id, self.channel_max, self.frame_max, self.heartbeat),
        )


class FrameConnectionOpen(Frame):
    __slots__ = ('virtual_host', 'capabilities', 'insist')
    name = 'connection.open'
    method_id = 0x000A0028  # 10,40 655400

    def __init__(self, virtual_host='/', capabilities='', insist=False):
        super(FrameConnectionOpen, self).__init__(virtual_host, capabilities, insist)

    @staticmethod
    def decode(buffer):
        virtual_host = buffer.read_string('!B')
        capabilities = buffer.read_string('!B')
        bits = buffer.read('!B')
        insist = bool(bits & 0x1)
        return FrameConnectionOpen(virtual_host, capabilities, insist)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.virtual_host)),
                self.virtual_host,
                struct.pack('!B', len(self.capabilities)),
                self.capabilities,
                struct.pack('!B', (self.insist and 0x1 or 0)),
            ])
        )


class FrameConnectionOpenOk(Frame):
    __slots__ = ('known_hosts',)
    name = 'connection.open_ok'
    method_id = 0x000A0029  # 10,41 655401

    def __init__(self, known_hosts=''):
        super(FrameConnectionOpenOk, self).__init__(known_hosts)

    @staticmethod
    def decode(buffer):
        known_hosts = buffer.read_string('!B')
        return FrameConnectionOpenOk(known_hosts)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.known_hosts)),
                self.known_hosts,
            ])
        )


class FrameConnectionClose(Frame):
    __slots__ = ('reply_code', 'reply_text', 'class_id', 'method_id')
    name = 'connection.close'
    method_id = 0x000A0032  # 10,50 655410

    def __init__(self, reply_code=None, reply_text='', class_id=None, method_id=None):
        super(FrameConnectionClose, self).__init__(reply_code, reply_text, class_id, method_id)

    @staticmethod
    def decode(buffer):
        reply_code = buffer.read('!H')
        reply_text = buffer.read_string('!B')
        class_id, method_id = buffer.read('!HH')
        return FrameConnectionClose(reply_code, reply_text, class_id, method_id)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.reply_code, len(self.reply_text)),
                self.reply_text,
                struct.pack('!HH', self.class_id, self.method_id),
            ])
        )


class FrameConnectionCloseOk(Frame):
    __slots__ = ()
    name = 'connection.close_ok'
    method_id = 0x000A0033  # 10,51 655411

    def __init__(self, ):
        super(FrameConnectionCloseOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameConnectionCloseOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameChannelOpen(Frame):
    __slots__ = ('out_of_band',)
    name = 'channel.open'
    method_id = 0x0014000A  # 20,10 1310730

    def __init__(self, out_of_band=''):
        super(FrameChannelOpen, self).__init__(out_of_band)

    @staticmethod
    def decode(buffer):
        out_of_band = buffer.read_string('!B')
        return FrameChannelOpen(out_of_band)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.out_of_band)),
                self.out_of_band,
            ])
        )


class FrameChannelOpenOk(Frame):
    __slots__ = ('channel_id',)
    name = 'channel.open_ok'
    method_id = 0x0014000B  # 20,11 1310731

    def __init__(self, channel_id=''):
        super(FrameChannelOpenOk, self).__init__(channel_id)

    @staticmethod
    def decode(buffer):
        channel_id = buffer.read_string('!I')
        return FrameChannelOpenOk(channel_id)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!II', self.method_id, len(self.channel_id)),
                self.channel_id,
            ])
        )


class FrameChannelFlow(Frame):
    __slots__ = ('active',)
    name = 'channel.flow'
    method_id = 0x00140014  # 20,20 1310740

    def __init__(self, active=None):
        super(FrameChannelFlow, self).__init__(active)

    @staticmethod
    def decode(buffer):
        bits = buffer.read('!B')
        active = bool(bits & 0x1)
        return FrameChannelFlow(active)

    def encode(self):
        yield (0x01,
            struct.pack('!IB', self.method_id, (self.active and 0x1 or 0)),
        )


class FrameChannelFlowOk(Frame):
    __slots__ = ('active',)
    name = 'channel.flow_ok'
    method_id = 0x00140015  # 20,21 1310741

    def __init__(self, active=None):
        super(FrameChannelFlowOk, self).__init__(active)

    @staticmethod
    def decode(buffer):
        bits = buffer.read('!B')
        active = bool(bits & 0x1)
        return FrameChannelFlowOk(active)

    def encode(self):
        yield (0x01,
            struct.pack('!IB', self.method_id, (self.active and 0x1 or 0)),
        )


class FrameChannelClose(Frame):
    __slots__ = ('reply_code', 'reply_text', 'class_id', 'method_id')
    name = 'channel.close'
    method_id = 0x00140028  # 20,40 1310760

    def __init__(self, reply_code=None, reply_text='', class_id=None, method_id=None):
        super(FrameChannelClose, self).__init__(reply_code, reply_text, class_id, method_id)

    @staticmethod
    def decode(buffer):
        reply_code = buffer.read('!H')
        reply_text = buffer.read_string('!B')
        class_id, method_id = buffer.read('!HH')
        return FrameChannelClose(reply_code, reply_text, class_id, method_id)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.reply_code, len(self.reply_text)),
                self.reply_text,
                struct.pack('!HH', self.class_id, self.method_id),
            ])
        )


class FrameChannelCloseOk(Frame):
    __slots__ = ()
    name = 'channel.close_ok'
    method_id = 0x00140029  # 20,41 1310761

    def __init__(self, ):
        super(FrameChannelCloseOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameChannelCloseOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameExchangeDeclare(Frame):
    __slots__ = ('ticket', 'exchange', 'type_', 'passive', 'durable', 'auto_delete', 'internal', 'nowait', 'arguments')
    name = 'exchange.declare'
    method_id = 0x0028000A  # 40,10 2621450

    def __init__(self, ticket=0, exchange=None, type_='direct', passive=False, durable=False, auto_delete=False, internal=False, nowait=False, arguments={}):
        super(FrameExchangeDeclare, self).__init__(ticket, exchange, type_, passive, durable, auto_delete, internal, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        exchange = buffer.read_string('!B')
        type_ = buffer.read_string('!B')
        bits = buffer.read('!B')
        passive = bool(bits & 0x1)
        durable = bool(bits & 0x2)
        auto_delete = bool(bits & 0x4)
        internal = bool(bits & 0x8)
        nowait = bool(bits & 0x10)
        arguments = buffer.read_table()
        return FrameExchangeDeclare(ticket, exchange, type_, passive, durable, auto_delete, internal, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.type_)),
                self.type_,
                struct.pack('!B', (self.passive and 0x1 or 0) | (self.durable and 0x2 or 0) | (self.auto_delete and 0x4 or 0) | (self.internal and 0x8 or 0) | (self.nowait and 0x10 or 0)),
                self.arguments_raw,
            ])
        )


class FrameExchangeDeclareOk(Frame):
    __slots__ = ()
    name = 'exchange.declare_ok'
    method_id = 0x0028000B  # 40,11 2621451

    def __init__(self, ):
        super(FrameExchangeDeclareOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameExchangeDeclareOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameExchangeDelete(Frame):
    __slots__ = ('ticket', 'exchange', 'if_unused', 'nowait')
    name = 'exchange.delete'
    method_id = 0x00280014  # 40,20 2621460

    def __init__(self, ticket=0, exchange=None, if_unused=False, nowait=False):
        super(FrameExchangeDelete, self).__init__(ticket, exchange, if_unused, nowait)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        exchange = buffer.read_string('!B')
        bits = buffer.read('!B')
        if_unused = bool(bits & 0x1)
        nowait = bool(bits & 0x2)
        return FrameExchangeDelete(ticket, exchange, if_unused, nowait)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.exchange)),
                self.exchange,
                struct.pack('!B', (self.if_unused and 0x1 or 0) | (self.nowait and 0x2 or 0)),
            ])
        )


class FrameExchangeDeleteOk(Frame):
    __slots__ = ()
    name = 'exchange.delete_ok'
    method_id = 0x00280015  # 40,21 2621461

    def __init__(self, ):
        super(FrameExchangeDeleteOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameExchangeDeleteOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameExchangeBind(Frame):
    __slots__ = ('ticket', 'destination', 'source', 'routing_key', 'nowait', 'arguments')
    name = 'exchange.bind'
    method_id = 0x0028001E  # 40,30 2621470

    def __init__(self, ticket=0, destination=None, source=None, routing_key='', nowait=False, arguments={}):
        super(FrameExchangeBind, self).__init__(ticket, destination, source, routing_key, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        destination = buffer.read_string('!B')
        source = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        arguments = buffer.read_table()
        return FrameExchangeBind(ticket, destination, source, routing_key, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.destination)),
                self.destination,
                struct.pack('!B', len(self.source)),
                self.source,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                struct.pack('!B', (self.nowait and 0x1 or 0)),
                self.arguments_raw,
            ])
        )


class FrameExchangeBindOk(Frame):
    __slots__ = ()
    name = 'exchange.bind_ok'
    method_id = 0x0028001F  # 40,31 2621471

    def __init__(self, ):
        super(FrameExchangeBindOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameExchangeBindOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameExchangeUnbind(Frame):
    __slots__ = ('ticket', 'destination', 'source', 'routing_key', 'nowait', 'arguments')
    name = 'exchange.unbind'
    method_id = 0x00280028  # 40,40 2621480

    def __init__(self, ticket=0, destination=None, source=None, routing_key='', nowait=False, arguments={}):
        super(FrameExchangeUnbind, self).__init__(ticket, destination, source, routing_key, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        destination = buffer.read_string('!B')
        source = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        arguments = buffer.read_table()
        return FrameExchangeUnbind(ticket, destination, source, routing_key, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.destination)),
                self.destination,
                struct.pack('!B', len(self.source)),
                self.source,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                struct.pack('!B', (self.nowait and 0x1 or 0)),
                self.arguments_raw,
            ])
        )


class FrameExchangeUnbindOk(Frame):
    __slots__ = ()
    name = 'exchange.unbind_ok'
    method_id = 0x00280033  # 40,51 2621491

    def __init__(self, ):
        super(FrameExchangeUnbindOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameExchangeUnbindOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameQueueDeclare(Frame):
    __slots__ = ('ticket', 'queue', 'passive', 'durable', 'exclusive', 'auto_delete', 'nowait', 'arguments')
    name = 'queue.declare'
    method_id = 0x0032000A  # 50,10 3276810

    def __init__(self, ticket=0, queue='', passive=False, durable=False, exclusive=False, auto_delete=False, nowait=False, arguments={}):
        super(FrameQueueDeclare, self).__init__(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        bits = buffer.read('!B')
        passive = bool(bits & 0x1)
        durable = bool(bits & 0x2)
        exclusive = bool(bits & 0x4)
        auto_delete = bool(bits & 0x8)
        nowait = bool(bits & 0x10)
        arguments = buffer.read_table()
        return FrameQueueDeclare(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', (self.passive and 0x1 or 0) | (self.durable and 0x2 or 0) | (self.exclusive and 0x4 or 0) | (self.auto_delete and 0x8 or 0) | (self.nowait and 0x10 or 0)),
                self.arguments_raw,
            ])
        )


class FrameQueueDeclareOk(Frame):
    __slots__ = ('queue', 'message_count', 'consumer_count')
    name = 'queue.declare_ok'
    method_id = 0x0032000B  # 50,11 3276811

    def __init__(self, queue=None, message_count=None, consumer_count=None):
        super(FrameQueueDeclareOk, self).__init__(queue, message_count, consumer_count)

    @staticmethod
    def decode(buffer):
        queue = buffer.read_string('!B')
        message_count, consumer_count = buffer.read('!II')
        return FrameQueueDeclareOk(queue, message_count, consumer_count)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.queue)),
                self.queue,
                struct.pack('!II', self.message_count, self.consumer_count),
            ])
        )


class FrameQueueBind(Frame):
    __slots__ = ('ticket', 'queue', 'exchange', 'routing_key', 'nowait', 'arguments')
    name = 'queue.bind'
    method_id = 0x00320014  # 50,20 3276820

    def __init__(self, ticket=0, queue='', exchange=None, routing_key='', nowait=False, arguments={}):
        super(FrameQueueBind, self).__init__(ticket, queue, exchange, routing_key, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        arguments = buffer.read_table()
        return FrameQueueBind(ticket, queue, exchange, routing_key, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                struct.pack('!B', (self.nowait and 0x1 or 0)),
                self.arguments_raw,
            ])
        )


class FrameQueueBindOk(Frame):
    __slots__ = ()
    name = 'queue.bind_ok'
    method_id = 0x00320015  # 50,21 3276821

    def __init__(self, ):
        super(FrameQueueBindOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameQueueBindOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameQueuePurge(Frame):
    __slots__ = ('ticket', 'queue', 'nowait')
    name = 'queue.purge'
    method_id = 0x0032001E  # 50,30 3276830

    def __init__(self, ticket=0, queue='', nowait=False):
        super(FrameQueuePurge, self).__init__(ticket, queue, nowait)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        return FrameQueuePurge(ticket, queue, nowait)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', (self.nowait and 0x1 or 0)),
            ])
        )


class FrameQueuePurgeOk(Frame):
    __slots__ = ('message_count',)
    name = 'queue.purge_ok'
    method_id = 0x0032001F  # 50,31 3276831

    def __init__(self, message_count=None):
        super(FrameQueuePurgeOk, self).__init__(message_count)

    @staticmethod
    def decode(buffer):
        message_count = buffer.read('!I')
        return FrameQueuePurgeOk(message_count)

    def encode(self):
        yield (0x01,
            struct.pack('!II', self.method_id, self.message_count),
        )


class FrameQueueDelete(Frame):
    __slots__ = ('ticket', 'queue', 'if_unused', 'if_empty', 'nowait')
    name = 'queue.delete'
    method_id = 0x00320028  # 50,40 3276840

    def __init__(self, ticket=0, queue='', if_unused=False, if_empty=False, nowait=False):
        super(FrameQueueDelete, self).__init__(ticket, queue, if_unused, if_empty, nowait)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        bits = buffer.read('!B')
        if_unused = bool(bits & 0x1)
        if_empty = bool(bits & 0x2)
        nowait = bool(bits & 0x4)
        return FrameQueueDelete(ticket, queue, if_unused, if_empty, nowait)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', (self.if_unused and 0x1 or 0) | (self.if_empty and 0x2 or 0) | (self.nowait and 0x4 or 0)),
            ])
        )


class FrameQueueDeleteOk(Frame):
    __slots__ = ('message_count',)
    name = 'queue.delete_ok'
    method_id = 0x00320029  # 50,41 3276841

    def __init__(self, message_count=None):
        super(FrameQueueDeleteOk, self).__init__(message_count)

    @staticmethod
    def decode(buffer):
        message_count = buffer.read('!I')
        return FrameQueueDeleteOk(message_count)

    def encode(self):
        yield (0x01,
            struct.pack('!II', self.method_id, self.message_count),
        )


class FrameQueueUnbind(Frame):
    __slots__ = ('ticket', 'queue', 'exchange', 'routing_key', 'arguments')
    name = 'queue.unbind'
    method_id = 0x00320032  # 50,50 3276850

    def __init__(self, ticket=0, queue='', exchange=None, routing_key='', arguments={}):
        super(FrameQueueUnbind, self).__init__(ticket, queue, exchange, routing_key, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        arguments = buffer.read_table()
        return FrameQueueUnbind(ticket, queue, exchange, routing_key, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                self.arguments_raw,
            ])
        )


class FrameQueueUnbindOk(Frame):
    __slots__ = ()
    name = 'queue.unbind_ok'
    method_id = 0x00320033  # 50,51 3276851

    def __init__(self, ):
        super(FrameQueueUnbindOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameQueueUnbindOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameBasicQos(Frame):
    __slots__ = ('prefetch_size', 'prefetch_count', 'global_')
    name = 'basic.qos'
    method_id = 0x003C000A  # 60,10 3932170

    def __init__(self, prefetch_size=0, prefetch_count=0, global_=False):
        super(FrameBasicQos, self).__init__(prefetch_size, prefetch_count, global_)

    @staticmethod
    def decode(buffer):
        prefetch_size, prefetch_count, bits = buffer.read('!IHB')
        global_ = bool(bits & 0x1)
        return FrameBasicQos(prefetch_size, prefetch_count, global_)

    def encode(self):
        yield (0x01,
            struct.pack('!IIHB', self.method_id, self.prefetch_size, self.prefetch_count, (self.global_ and 0x1 or 0)),
        )


class FrameBasicQosOk(Frame):
    __slots__ = ()
    name = 'basic.qos_ok'
    method_id = 0x003C000B  # 60,11 3932171

    def __init__(self, ):
        super(FrameBasicQosOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameBasicQosOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameBasicConsume(Frame):
    __slots__ = ('ticket', 'queue', 'consumer_tag', 'no_local', 'no_ack', 'exclusive', 'nowait', 'arguments')
    name = 'basic.consume'
    method_id = 0x003C0014  # 60,20 3932180

    def __init__(self, ticket=0, queue='', consumer_tag='', no_local=False, no_ack=False, exclusive=False, nowait=False, arguments={}):
        super(FrameBasicConsume, self).__init__(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        consumer_tag = buffer.read_string('!B')
        bits = buffer.read('!B')
        no_local = bool(bits & 0x1)
        no_ack = bool(bits & 0x2)
        exclusive = bool(bits & 0x4)
        nowait = bool(bits & 0x8)
        arguments = buffer.read_table()
        return FrameBasicConsume(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)

    def encode(self):
        arguments_raw = table.encode(self.arguments)
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', len(self.consumer_tag)),
                self.consumer_tag,
                struct.pack('!B', (self.no_local and 0x1 or 0) | (self.no_ack and 0x2 or 0) | (self.exclusive and 0x4 or 0) | (self.nowait and 0x8 or 0)),
                self.arguments_raw,
            ])
        )


class FrameBasicConsumeOk(Frame):
    __slots__ = ('consumer_tag',)
    name = 'basic.consume_ok'
    method_id = 0x003C0015  # 60,21 3932181

    def __init__(self, consumer_tag=None):
        super(FrameBasicConsumeOk, self).__init__(consumer_tag)

    @staticmethod
    def decode(buffer):
        consumer_tag = buffer.read_string('!B')
        return FrameBasicConsumeOk(consumer_tag)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.consumer_tag)),
                self.consumer_tag,
            ])
        )


class FrameBasicCancel(Frame):
    __slots__ = ('consumer_tag', 'nowait')
    name = 'basic.cancel'
    method_id = 0x003C001E  # 60,30 3932190

    def __init__(self, consumer_tag=None, nowait=False):
        super(FrameBasicCancel, self).__init__(consumer_tag, nowait)

    @staticmethod
    def decode(buffer):
        consumer_tag = buffer.read_string('!B')
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        return FrameBasicCancel(consumer_tag, nowait)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.consumer_tag)),
                self.consumer_tag,
                struct.pack('!B', (self.nowait and 0x1 or 0)),
            ])
        )


class FrameBasicCancelOk(Frame):
    __slots__ = ('consumer_tag',)
    name = 'basic.cancel_ok'
    method_id = 0x003C001F  # 60,31 3932191

    def __init__(self, consumer_tag=None):
        super(FrameBasicCancelOk, self).__init__(consumer_tag)

    @staticmethod
    def decode(buffer):
        consumer_tag = buffer.read_string('!B')
        return FrameBasicCancelOk(consumer_tag)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.consumer_tag)),
                self.consumer_tag,
            ])
        )


class FrameBasicPublish(Frame):
    __slots__ = ('ticket', 'exchange', 'routing_key', 'mandatory', 'immediate')
    name = 'basic.publish'
    method_id = 0x003C0028  # 60,40 3932200
    has_content = True
    class_id = CLASS_BASIC

    def __init__(self, ticket=0, exchange='', routing_key='', mandatory=False, immediate=False):
        super(FrameBasicPublish, self).__init__(ticket, exchange, routing_key, mandatory, immediate)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        bits = buffer.read('!B')
        mandatory = bool(bits & 0x1)
        immediate = bool(bits & 0x2)
        return FrameBasicPublish(ticket, exchange, routing_key, mandatory, immediate)

    def encode(self):
        props, headers = split_headers(self.user_headers, BASIC_PROPS_SET)
        if headers:
            props['headers'] = headers
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                struct.pack('!B', (self.mandatory and 0x1 or 0) | (self.immediate and 0x2 or 0)),
            ])
        )


class FrameBasicReturn(Frame):
    __slots__ = ('reply_code', 'reply_text', 'exchange', 'routing_key')
    name = 'basic.return'
    method_id = 0x003C0032  # 60,50 3932210
    has_content = True
    class_id = CLASS_BASIC

    def __init__(self, reply_code=None, reply_text='', exchange=None, routing_key=None):
        super(FrameBasicReturn, self).__init__(reply_code, reply_text, exchange, routing_key)

    @staticmethod
    def decode(buffer):
        reply_code = buffer.read('!H')
        reply_text = buffer.read_string('!B')
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        return FrameBasicReturn(reply_code, reply_text, exchange, routing_key)

    def encode(self):
        props, headers = split_headers(self.user_headers, BASIC_PROPS_SET)
        if headers:
            props['headers'] = headers
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.reply_code, len(self.reply_text)),
                self.reply_text,
                struct.pack('!B', len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
            ])
        )


class FrameBasicDeliver(Frame):
    __slots__ = ('consumer_tag', 'delivery_tag', 'redelivered', 'exchange', 'routing_key')
    name = 'basic.deliver'
    method_id = 0x003C003C  # 60,60 3932220
    has_content = True
    class_id = CLASS_BASIC

    def __init__(self, consumer_tag=None, delivery_tag=None, redelivered=False, exchange=None, routing_key=None):
        super(FrameBasicDeliver, self).__init__(consumer_tag, delivery_tag, redelivered, exchange, routing_key)

    @staticmethod
    def decode(buffer):
        consumer_tag = buffer.read_string('!B')
        delivery_tag, bits = buffer.read('!QB')
        redelivered = bool(bits & 0x1)
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        return FrameBasicDeliver(consumer_tag, delivery_tag, redelivered, exchange, routing_key)

    def encode(self):
        props, headers = split_headers(self.user_headers, BASIC_PROPS_SET)
        if headers:
            props['headers'] = headers
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.consumer_tag)),
                self.consumer_tag,
                struct.pack('!QBB', self.delivery_tag, (self.redelivered and 0x1 or 0), len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
            ])
        )


class FrameBasicGet(Frame):
    __slots__ = ('ticket', 'queue', 'no_ack')
    name = 'basic.get'
    method_id = 0x003C0046  # 60,70 3932230

    def __init__(self, ticket=0, queue='', no_ack=False):
        super(FrameBasicGet, self).__init__(ticket, queue, no_ack)

    @staticmethod
    def decode(buffer):
        ticket = buffer.read('!H')
        queue = buffer.read_string('!B')
        bits = buffer.read('!B')
        no_ack = bool(bits & 0x1)
        return FrameBasicGet(ticket, queue, no_ack)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IHB', self.method_id, self.ticket, len(self.queue)),
                self.queue,
                struct.pack('!B', (self.no_ack and 0x1 or 0)),
            ])
        )


class FrameBasicGetOk(Frame):
    __slots__ = ('delivery_tag', 'redelivered', 'exchange', 'routing_key', 'message_count')
    name = 'basic.get_ok'
    method_id = 0x003C0047  # 60,71 3932231
    has_content = True
    class_id = CLASS_BASIC

    def __init__(self, delivery_tag=None, redelivered=False, exchange=None, routing_key=None, message_count=None):
        super(FrameBasicGetOk, self).__init__(delivery_tag, redelivered, exchange, routing_key, message_count)

    @staticmethod
    def decode(buffer):
        delivery_tag, bits = buffer.read('!QB')
        redelivered = bool(bits & 0x1)
        exchange = buffer.read_string('!B')
        routing_key = buffer.read_string('!B')
        message_count = buffer.read('!I')
        return FrameBasicGetOk(delivery_tag, redelivered, exchange, routing_key, message_count)

    def encode(self):
        props, headers = split_headers(self.user_headers, BASIC_PROPS_SET)
        if headers:
            props['headers'] = headers
        yield (0x01,
            ''.join([
                struct.pack('!IQBB', self.method_id, self.delivery_tag, (self.redelivered and 0x1 or 0), len(self.exchange)),
                self.exchange,
                struct.pack('!B', len(self.routing_key)),
                self.routing_key,
                struct.pack('!I', self.message_count),
            ])
        )


class FrameBasicGetEmpty(Frame):
    __slots__ = ('cluster_id',)
    name = 'basic.get_empty'
    method_id = 0x003C0048  # 60,72 3932232

    def __init__(self, cluster_id=''):
        super(FrameBasicGetEmpty, self).__init__(cluster_id)

    @staticmethod
    def decode(buffer):
        cluster_id = buffer.read_string('!B')
        return FrameBasicGetEmpty(cluster_id)

    def encode(self):
        yield (0x01,
            ''.join([
                struct.pack('!IB', self.method_id, len(self.cluster_id)),
                self.cluster_id,
            ])
        )


class FrameBasicAck(Frame):
    __slots__ = ('delivery_tag', 'multiple')
    name = 'basic.ack'
    method_id = 0x003C0050  # 60,80 3932240

    def __init__(self, delivery_tag=0, multiple=False):
        super(FrameBasicAck, self).__init__(delivery_tag, multiple)

    @staticmethod
    def decode(buffer):
        delivery_tag, bits = buffer.read('!QB')
        multiple = bool(bits & 0x1)
        return FrameBasicAck(delivery_tag, multiple)

    def encode(self):
        yield (0x01,
            struct.pack('!IQB', self.method_id, self.delivery_tag, (self.multiple and 0x1 or 0)),
        )


class FrameBasicReject(Frame):
    __slots__ = ('delivery_tag', 'requeue')
    name = 'basic.reject'
    method_id = 0x003C005A  # 60,90 3932250

    def __init__(self, delivery_tag=None, requeue=True):
        super(FrameBasicReject, self).__init__(delivery_tag, requeue)

    @staticmethod
    def decode(buffer):
        delivery_tag, bits = buffer.read('!QB')
        requeue = bool(bits & 0x1)
        return FrameBasicReject(delivery_tag, requeue)

    def encode(self):
        yield (0x01,
            struct.pack('!IQB', self.method_id, self.delivery_tag, (self.requeue and 0x1 or 0)),
        )


class FrameBasicRecoverAsync(Frame):
    __slots__ = ('requeue',)
    name = 'basic.recover_async'
    method_id = 0x003C0064  # 60,100 3932260

    def __init__(self, requeue=False):
        super(FrameBasicRecoverAsync, self).__init__(requeue)

    @staticmethod
    def decode(buffer):
        bits = buffer.read('!B')
        requeue = bool(bits & 0x1)
        return FrameBasicRecoverAsync(requeue)

    def encode(self):
        yield (0x01,
            struct.pack('!IB', self.method_id, (self.requeue and 0x1 or 0)),
        )


class FrameBasicRecover(Frame):
    __slots__ = ('requeue',)
    name = 'basic.recover'
    method_id = 0x003C006E  # 60,110 3932270

    def __init__(self, requeue=False):
        super(FrameBasicRecover, self).__init__(requeue)

    @staticmethod
    def decode(buffer):
        bits = buffer.read('!B')
        requeue = bool(bits & 0x1)
        return FrameBasicRecover(requeue)

    def encode(self):
        yield (0x01,
            struct.pack('!IB', self.method_id, (self.requeue and 0x1 or 0)),
        )


class FrameBasicRecoverOk(Frame):
    __slots__ = ()
    name = 'basic.recover_ok'
    method_id = 0x003C006F  # 60,111 3932271

    def __init__(self, ):
        super(FrameBasicRecoverOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameBasicRecoverOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )


class FrameBasicNack(Frame):
    __slots__ = ('delivery_tag', 'multiple', 'requeue')
    name = 'basic.nack'
    method_id = 0x003C0078  # 60,120 3932280

    def __init__(self, delivery_tag=0, multiple=False, requeue=True):
        super(FrameBasicNack, self).__init__(delivery_tag, multiple, requeue)

    @staticmethod
    def decode(buffer):
        delivery_tag, bits = buffer.read('!QB')
        multiple = bool(bits & 0x1)
        requeue = bool(bits & 0x2)
        return FrameBasicNack(delivery_tag, multiple, requeue)

    def encode(self):
        yield (0x01,
            struct.pack('!IQB', self.method_id, self.delivery_tag, (self.multiple and 0x1 or 0) | (self.requeue and 0x2 or 0)),
        )


class FrameConfirmSelect(Frame):
    __slots__ = ('nowait',)
    name = 'confirm.select'
    method_id = 0x0055000A  # 85,10 5570570

    def __init__(self, nowait=False):
        super(FrameConfirmSelect, self).__init__(nowait)

    @staticmethod
    def decode(buffer):
        bits = buffer.read('!B')
        nowait = bool(bits & 0x1)
        return FrameConfirmSelect(nowait)

    def encode(self):
        yield (0x01,
            struct.pack('!IB', self.method_id, (self.nowait and 0x1 or 0)),
        )


class FrameConfirmSelectOk(Frame):
    __slots__ = ()
    name = 'confirm.select_ok'
    method_id = 0x0055000B  # 85,11 5570571

    def __init__(self, ):
        super(FrameConfirmSelectOk, self).__init__()

    @staticmethod
    def decode(buffer):
        return FrameConfirmSelectOk()

    def encode(self):
        yield (0x01,
            struct.pack('!I', self.method_id),
        )



def decode_basic_properties(buffer):
    props = {}
    flags, = buffer.read('!H')
    assert (flags & 0x01) == 0
    if (flags & 0x8000): # 1 << 15
        props['content_type'] = buffer.read_string('!B')
    if (flags & 0x4000): # 1 << 14
        props['content_encoding'] = buffer.read_string('!B')
    if (flags & 0x2000): # 1 << 13
        props['headers'] = buffer.read_table()
    if (flags & 0x1000): # 1 << 12
        props['delivery_mode'] = buffer.read('!B')
    if (flags & 0x0800): # 1 << 11
        props['priority'] = buffer.read('!B')
    if (flags & 0x0400): # 1 << 10
        props['correlation_id'] = buffer.read_string('!B')
    if (flags & 0x0200): # 1 << 9
        props['reply_to'] = buffer.read_string('!B')
    if (flags & 0x0100): # 1 << 8
        props['expiration'] = buffer.read_string('!B')
    if (flags & 0x0080): # 1 << 7
        props['message_id'] = buffer.read_string('!B')
    if (flags & 0x0040): # 1 << 6
        props['timestamp'] = buffer.read('!Q')
    if (flags & 0x0020): # 1 << 5
        props['type_'] = buffer.read_string('!B')
    if (flags & 0x0010): # 1 << 4
        props['user_id'] = buffer.read_string('!B')
    if (flags & 0x0008): # 1 << 3
        props['app_id'] = buffer.read_string('!B')
    if (flags & 0x0004): # 1 << 2
        props['cluster_id'] = buffer.read_string('!B')
    return props


PROPS = {
    CLASS_BASIC: decode_basic_properties, 	# 60
}


BASIC_PROPS_SET = set((
    "content_type",      # shortstr
    "content_encoding",  # shortstr
    "headers",           # table
    "delivery_mode",     # octet
    "priority",          # octet
    "correlation_id",    # shortstr
    "reply_to",          # shortstr
    "expiration",        # shortstr
    "message_id",        # shortstr
    "timestamp",         # timestamp
    "type_",             # shortstr
    "user_id",           # shortstr
    "app_id",            # shortstr
    "cluster_id",        # shortstr
    ))

ENCODE_PROPS_BASIC = {
    'content_type': (
        0,
        0x8000, # (1 << 15)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'content_encoding': (
        1,
        0x4000, # (1 << 14)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'headers': (
        2,
        0x2000, # (1 << 13)
        lambda val: table.encode(val)
        ),
    'delivery_mode': (
        3,
        0x1000, # (1 << 12)
        lambda val: struct.pack('!B', val)
        ),
    'priority': (
        4,
        0x0800, # (1 << 11)
        lambda val: struct.pack('!B', val)
        ),
    'correlation_id': (
        5,
        0x0400, # (1 << 10)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'reply_to': (
        6,
        0x0200, # (1 << 9)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'expiration': (
        7,
        0x0100, # (1 << 8)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'message_id': (
        8,
        0x0080, # (1 << 7)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'timestamp': (
        9,
        0x0040, # (1 << 6)
        lambda val: struct.pack('!Q', val)
        ),
    'type_': (
        10,
        0x0020, # (1 << 5)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'user_id': (
        11,
        0x0010, # (1 << 4)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'app_id': (
        12,
        0x0008, # (1 << 3)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
    'cluster_id': (
        13,
        0x0004, # (1 << 2)
        lambda val: ''.join((
                struct.pack('!B', len(val)),
                val,
        )) ),
}

def encode_basic_properties(body_size, props):
    pieces = ['']*14
    flags = 0
    enc = ENCODE_PROPS_BASIC

    for key in BASIC_PROPS_SET & set(props.iterkeys()):
        i, f, fun = enc[key]
        flags |= f
        pieces[i] = fun(props[key])

    return (0x02, ''.join((
        struct.pack('!HHQH',
                    CLASS_BASIC, 0, body_size, flags),
        ''.join(pieces),
        ))
        )

